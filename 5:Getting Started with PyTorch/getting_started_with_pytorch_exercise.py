# -*- coding: utf-8 -*-
"""Getting_Started_with_PyTorch_Exercise.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rDeK_NeL4PMUuUheUpbtcwpAG_9dwN7E

# Problem Statement: **Welcome to AI Town!**

### You’ve been hired as an AI engineer in **AI Town**, a futuristic city powered by artificial intelligence. Your job is to use PyTorch to solve foundational challenges that AI Town faces. Each task requires you to demonstrate your expertise with PyTorch basics.

---

Imports and CUDA
"""

import torch

# Check if CUDA (GPU) is available
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
print(f"Using device: {device}")

"""---

**Task1: Inventory Management**

AI Town’s warehouse uses sensors to record the inventory of 5 items every day. Each day’s data is represented as a list of integers (number of units).
"""

#1 Create a PyTorch Tensor from the following inventory data
inventory = [[12, 15, 10, 0, 5],
             [10, 8, 7, 5, 4],
             [20, 10, 15, 5, 2]]

inventory_tensor = torch.tensor(inventory)
print(inventory_tensor)

#2 Find the total inventory for each item across all days
total_inventory = inventory_tensor.sum(dim=0)
print(total_inventory)

#3 Find the average inventory per day
average_inventory = inventory_tensor.float().mean(dim=1)
print(average_inventory)

"""---

**Task2: Monitoring Vehicle Flow**

AI Town uses a sensor to monitor the number of vehicles passing through two main roads every hour. The data for one day (24 hours) is represented as two
1×24 tensors.
"""

#1 Simulate this data using PyTorch's Random Functions
torch.manual_seed(42)
road1 = torch.randint(50, 200, (24, ), dtype=torch.float)
road2 = torch.randint(50, 200, (24, ), dtype=torch.float)
print(road1)
print(road2)

#2 Write the function to calculate the total vehicle flow for each road across the entire day
total_flow_road1 = road1.sum() # total for road1
total_flow_road2 = road2.sum() # total for road2
print(total_flow_road1)
print(total_flow_road2)

#3 Write the function to calculate the total vehicle flow for each hour across both roads
def total_vehicle_flow_per_hour(road1, road2):
  return torch.stack([road1.sum(), road2.sum()])

total_vehicle_flow_per_hour(road1, road2)

"""---

**Task3: Fitness Matrix**

The AI Gym tracks members’ fitness scores using a 3×3 matrix for *strength*, *stamina*, and f*lexibility*. Each row represents a different member, and each column represents a specific metric.
"""

#1 Create a 3*3 tensor matrix and multiply the scores of each member by a weight factor: [0.8, 1.2, 1.5]
torch.manual_seed(42)
fitness_matrix = torch.randint(1, 10, (3, 3), dtype=torch.float)
print(fitness_matrix)

#2 Find the row-wise and column-wise maximum scores
print(torch.max(fitness_matrix, dim=0))
print(torch.max(fitness_matrix, dim=1))

#3 Transpose the fitness matrix and interpret it's new structure (shape)
print(fitness_matrix.T)

"""---

**Task4: Chain Rule in Action**

AI Lab is running experiments to understand the effect of temperature (
x) on a chemical reaction rate (y). The relationship is given as:
$y = 2x^3 + 5x^2 - 3x + 7$
"""

#1 Use PyTorch to compute 'y' for x = 4
x = torch.tensor(4.0, requires_grad=True)
y = 2 * x**3 + 5 * x**2 - 3 * x + 7
print(y)

#2 Calculate dy/dx(gradient) using PyTorch's autograd
y.backward()
print(x.grad)

"""---

**Task5: Camera Calibration**

AI Town’s surveillance cameras need to align their focus. You are given the following matrices for two cameras’ focus adjustments:
"""

'''
camera1 = torch.tensor([[1, 2], [3, 4]])
camera2 = torch.tensor([[5, 6], [7, 8]])
'''

#1 Perform an element-wise multiplication of matrices ( Hadamard Product)
camera1 = torch.tensor([[1, 2], [3, 4]], dtype=torch.float)
camera2 = torch.tensor([[5, 6], [7, 8]], dtype=torch.float)
torch.mul(camera1, camera2)

#2 Compute Dot Product of the two matrices
torch.matmul(camera1, camera2)

#3 Compute the Determinant of each matrix
print(torch.linalg.det(camera1))
print(torch.linalg.det(camera2))

"""---

**Task6: Neural Network Foundations**

Our AI University uses simplified single neuron model (perceptron):
$$y = wx + b$$
"""

#1 Create tensors for w  = 2, b = 1, x = [1, 2, 3, 4]
w = torch.tensor(2.0, requires_grad=True)
b = torch.tensor(1.0, requires_grad=True)
x = torch.tensor([1, 2, 3, 4], dtype=torch.float, requires_grad=True)

#2 Compute tensors for y
y = w * x + b
print(y)

"""

---

"""